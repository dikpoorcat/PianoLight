#include "WS2812.h"


u8 RGB_use0[32][3];
u8 RGB_use1[32][3];


//u8 RGB_luanxie[25][3]=	//顺序为RGB  PS:有人说数组寻址比结构体快
//{
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,	
//	
//	0xFF,0xEB,0xCD,		
//	0xFF,0xE7,0xBA,
//	0xFF,0xE4,0xE1,		
//	0xFF,0xE4,0xC4,		
//	0xFF,0xE4,0xB5,
//	
//	0xFF,0xE1,0xFF,
//	0xFF,0xDE,0xAD,	
//	0xFF,0xDA,0xB9,		
//	0xFF,0xD7,0x00,		
//	0xFF,0xD3,0x9B,
//	
//	0xFF,0xC1,0xC1,		
//	0xFF,0xC1,0x25,		
//	0xFF,0xC0,0xCB,		
//	0xFF,0xBB,0xFF,
//	0xFF,0xB9,0x0F,
//	
//	0xFF,0xB6,0xC1,		
//	0xFF,0xB5,0xC5,		
//	0xFF,0xAE,0xB9,
//	0xFF,0xA5,0x4F,		
//	0xFF,0xA5,0x00		
//};	

//u8 RGB_luanxie1[25][3]=	//顺序为RGB  PS:有人说数组寻址比结构体快
//{
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,	
//	
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,	
//	
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,	
//	
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,	
//	
//	0xff,0x00,0x00,		//红
//	0x00,0xff,0x00,		//绿
//	0x00,0x00,0xff,		//蓝
//	0xFF,0xEF,0xD5,		
//	0xFF,0xEC,0x8B,		
//};	

//u8 RGB_huxi1[25][3]={{0},{0},{0},{0},{0},{0,255,255},{0,255,255},{0,255,255},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0,255,255},{0,255,255},{0,255,255},{0},{0},{0},{0},{0}};
//u8 RGB_huxi2[25][3]={{0},{0},{0},{0},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{0},{0},{0},{0},{0},{0},{0},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{0},{0},{0},{0}};	

//u8 RGB_red0[25][3]={{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9},{0xf9}};			//顺序为RGB 

//u8 RGB_black[25][3]={0};	//顺序为RGB 
//u8 RGB_red[25][3]={{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff},{0xff}};			//顺序为RGB 
//u8 RGB_red1[25][3]={{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f},{0x7f}};			//顺序为RGB 
//u8 RGB_red2[25][3]={{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18},{0x18}};			//顺序为RGB 
//u8 RGB_green[25][3]={{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff},{0,0xff}};			//顺序为RGB 
////
//u8 RGB_green2[25][3]={{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18},{0,0x18}};			//顺序为RGB 
//u8 RGB_blue[25][3]={{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff},{0,0,0xff}};			//顺序为RGB 

//u8 RGB_blue2[25][3]={{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18},{0,0,0x18}};			//顺序为RGB 
//u8 RGB_zanting1[25][3]={{0},{0},{0},{0},{0},{0,255,255},{0,255,255},{0,255,255},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0,255,255},{0,255,255},{0,255,255},{0},{0},{0},{0},{0}};
//u8 RGB_zanting2[25][3]={{0},{0},{0},{0},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{0},{0},{0},{0},{0},{0},{0},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{250,210,6},{0},{0},{0},{0}};	
	
	
/*******************************************************************************
名称：void WS2812_init(void)
功能： 初始化LED条
入参：
出参：
返回：
*******************************************************************************/
void WS2812_init(void)
{
	RCC->APB2ENR|=1<<2;  		//PORTA时钟使能 	  
	GPIOA->CRL&=0X00FFFFFF; 
	GPIOA->CRL|=0X33000000;		//PA7/6(3推挽，7开漏）输出
//	GPIOA->CRL&=0XFFFF00FF; 
//	GPIOA->CRL|=0X00003300;		//PA3/2(3推挽，7开漏）输出		
}

/*******************************************************************************
名称：void CreateArray(u8 R,u8 G,u8 B,u32 Mark,u8 Num,u8 * Array)
功能：按Mark生成RGB数组（控制规则），在Mark为1的对应位上写入给定的RGB值 
入参：u8 R,u8 G,u8 B,u32 Mark,u8 Num,LED个数；u8 * Array
出参：u8 * Array指向生成的数组
返回：
*******************************************************************************/	
void CreateArray(u8 R,u8 G,u8 B,u32 Mark,u8 Num,u8 * Array)
{
	u8 i;	
	for(i=0;i<Num;i++)
	{
		if(Mark&0x00000001)
		{
			*(Array+3*i)=R;
			*(Array+3*i+1)=G;
			*(Array+3*i+2)=B;
		}
		else
		{
			*(Array+3*i)=0;
			*(Array+3*i+1)=0;
			*(Array+3*i+2)=0;
		}
		Mark=Mark>>1;
	}
}

/*******************************************************************************
名称：void Jianmang(u8 R0,u8 G0,u8 B0,u8 R1,u8 G1,u8 B1,u8 Num,u16 time)
功能：单色流星渐满效果,LED0/1色彩可指定，安装后由下向上渐满，如同注水。控制LED0和LED1在time时间内按Num个LED预亮渐满整周，颜色为输入的RGB
入参：Num为预亮LED个数；time为渐满时长（毫秒）；R/G/B组成输入的色彩，分别对应LED0/1
出参：
返回：
*******************************************************************************/		
void Jianmang(u8 R0,u8 G0,u8 B0,u8 R1,u8 G1,u8 B1,u8 Num,u16 time)
{
	u8 i;
	u8 j=0;
	u8 t;
	u8 n_R0;
	u8 n_G0;
	u8 n_B0;
	u8 n_R1;
	u8 n_G1;
	u8 n_B1;
	u8 RGB0[26][3]={0};							//多给一个用于保存RGB[25](无用)，避免报错
	u8 RGB1[26][3]={0};							//多给一个用于保存RGB[25](无用)，避免报错
	
	n_R0=R0/Num;								//当前色每次需递增的亮度
	n_G0=G0/Num;								//当前色每次需递增的亮度
	n_B0=B0/Num;								//当前色每次需递增的亮度
	n_R1=R1/Num;								//当前色每次需递增的亮度
	n_G1=G1/Num;								//当前色每次需递增的亮度
	n_B1=B1/Num;								//当前色每次需递增的亮度

	t=time/25;									//每次亮灯时间
		
	for(i=0;i<13;i++)							//下往上13个LED依次点亮	
	{	
		for(j=0;j<Num;j++)
		{
			if(i-j<0) break;					//小于0的不管
			RGB0[i-j][0]+=n_R0;
			RGB0[i-j][1]+=n_G0;
			RGB0[i-j][2]+=n_B0;	
			RGB0[25-i+j][0]+=n_R0;
			RGB0[25-i+j][1]+=n_G0;
			RGB0[25-i+j][2]+=n_B0;	
			RGB1[i-j][0]+=n_R1;
			RGB1[i-j][1]+=n_G1;
			RGB1[i-j][2]+=n_B1;
			RGB1[25-i+j][0]+=n_R1;
			RGB1[25-i+j][1]+=n_G1;
			RGB1[25-i+j][2]+=n_B1;		
		}
		Light_LED(LED0,&RGB0[0][0],25);			//以&RGB0[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB1[0][0],25);			//以&RGB1[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN
		if(state!=CD) break;
#endif
	}
	//11、12、13、14号LED亮度未满补足
	for(j=0;j<2;j++)
	{
		RGB0[11+j][0]+=n_R0;
		RGB0[11+j][1]+=n_G0;
		RGB0[11+j][2]+=n_B0;	
		RGB0[14-j][0]+=n_R0;
		RGB0[14-j][1]+=n_G0;
		RGB0[14-j][2]+=n_B0;	
		RGB1[i-j][0]+=n_R1;
		RGB1[i-j][1]+=n_G1;
		RGB1[i-j][2]+=n_B1;
		RGB1[14-j][0]+=n_R1;
		RGB1[14-j][1]+=n_G1;
		RGB1[14-j][2]+=n_B1;		
	}
	Light_LED(LED0,&RGB0[0][0],25);				//以&RGB0[0][0]为规则，将LED0点亮25个
	Light_LED(LED1,&RGB1[0][0],25);				//以&RGB1[0][0]为规则，将LED1点亮25个
	delay_ms(t);								//亮t(ms)
	IWDG_Feed();								//喂狗
	//12、13号LED亮度未满补足
	RGB0[12][0]+=n_R0;
	RGB0[12][1]+=n_G0;
	RGB0[12][2]+=n_B0;	
	RGB0[13][0]+=n_R0;
	RGB0[13][1]+=n_G0;
	RGB0[13][2]+=n_B0;	
	RGB1[12][0]+=n_R1;
	RGB1[12][1]+=n_G1;
	RGB1[12][2]+=n_B1;
	RGB1[13][0]+=n_R1;
	RGB1[13][1]+=n_G1;
	RGB1[13][2]+=n_B1;		
	Light_LED(LED0,&RGB0[0][0],25);				//以&RGB0[0][0]为规则，将LED0点亮25个
	Light_LED(LED1,&RGB1[0][0],25);				//以&RGB1[0][0]为规则，将LED1点亮25个
	delay_ms(t);								//亮t(ms)
	IWDG_Feed();								//喂狗
}

/*******************************************************************************
名称：void Liushui(u8 R0,u8 G0,u8 B0,u8 R1,u8 G1,u8 B1,u8 Num,u16 time)
功能：单色流星效果流水灯,LED0/1色彩可指定，两LED灯串亮灯方向相反。控制LED0和LED1在time时间内按Num个LED旋转一周渐弱，颜色为输入的RGB
入参：Num为渐弱LED个数；time为渐弱时长（毫秒）；R/G/B组成输入的色彩，分别对应LED0/1
出参：
返回：
*******************************************************************************/		
void Liushui(u8 R0,u8 G0,u8 B0,u8 R1,u8 G1,u8 B1,u8 Num,u16 time)
{
	u8 i;
	u8 j=0;
	u8 t;
	u8 n_R0;
	u8 n_G0;
	u8 n_B0;
	u8 n_R1;
	u8 n_G1;
	u8 n_B1;
	u8 RGB0[50][3];								//用于保存创建的亮灯规则
	u8 RGB1[50][3];								//用于保存创建的亮灯规则
	
	n_R0=R0/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	n_G0=G0/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	n_B0=B0/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	n_R1=R1/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	n_G1=G1/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	n_B1=B1/Num+1;								//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
	
	for(i=0;i<25;i++)							//创建亮灯规则					
	{
		RGB0[i][0]=RGB0[i+25][0]=R0;
		RGB0[i][1]=RGB0[i+25][1]=G0;
		RGB0[i][2]=RGB0[i+25][2]=B0;
		RGB1[50-i][0]=RGB1[25-i][0]=R1;
		RGB1[50-i][1]=RGB1[25-i][1]=G1;
		RGB1[50-i][2]=RGB1[25-i][2]=B1;		
		if(R0>=n_R0)							//计算LED0渐弱后的亮度
		{			
			R0-=n_R0;
		}
		else R0=0;
		if(G0>=n_G0)
		{			
			G0-=n_G0;
		}
		else G0=0;
		if(B0>=n_B0)
		{			
			B0-=n_B0;
		}
		else B0=0;	
		
		if(R1>=n_R1)							//计算LED1渐弱后的亮度
		{			
			R1-=n_R1;
		}
		else R1=0;
		if(G1>=n_G1)
		{			
			G1-=n_G1;
		}
		else G1=0;
		if(B1>=n_B1)
		{			
			B1-=n_B1;
		}
		else B1=0;	
	}

	t=time/(Num+1);								//每次亮灯时间
		
	for(i=0;i<25;i++)							//一圈25个LED依次点亮	
	{	
		Light_LED(LED0,&RGB0[i][0],25);			//以&RGB[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB1[25-i][0],25);		//以&RGB[0][0]为规则，将LED1点亮25个
		if(i<13) j+=(time/60);
		else j-=(time/60);
		delay_ms(t+j);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN		
		if(state!=ZC) break;
#endif
	}	
}
	
/*******************************************************************************
名称：void Jianruo(u8 * Array,u8 Num,u16 time)
功能： 以Array为规则，控制LED0和LED1在time时间内按Num层亮度渐弱
入参：Num为渐弱层数；time为渐弱时长（毫秒）；* Array指向亮灯规则
出参：
返回：
*******************************************************************************/		
void Jianruo(u8 * Array,u8 Num,u16 time)
{
	u8 i;
	u8 j;
	u8 t;
	u8 n;
	u8 RGB[25][3];								//用于保存原始亮灯规则
	u8 RGB_n[25][3];							//用于保存亮度递减规则
	
	for(i=0;i<25;i++)							
	{
		for(j=0;j<3;j++)
		{
			RGB[i][j]=*(Array+3*i+j);			//保存原始亮灯规则
			n=(*(Array+3*i+j))/Num+1;			//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+1）
			RGB_n[i][j]=n;						//保存亮度递减规则
		}
	}
	
	t=time/(Num+1);								//每次亮灯时间	
	
	for(i=0;i<Num;i++)							//分Num层渐弱，如3时为亮-中等-灭	
	{
		reduct(&RGB[0][0],&RGB_n[0][0],25);		//将&RGB[0][0]所指的前25行元素减去对应的RGB_n，相当于前25个LED亮度减少RGB_n
		Light_LED(LED0,&RGB[0][0],25);			//以&RGB[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB[0][0],25);			//以&RGB[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN		
		if(state!=GZ) break;
#endif		
	}
}

/*******************************************************************************
名称：void Jianruo2(u8 * Array_A,u8 * Array_B,u8 Num,u16 time)
功能： 以Array_A和Array_B为规则，分别控制LED0和LED1在time时间内按Num层亮度渐弱
入参：Num为渐弱层数；time为渐弱时长（毫秒）；* Array指向亮灯规则
出参：
返回：
*******************************************************************************/		
void Jianruo2(u8 * Array_A,u8 * Array_B,u8 Num,u16 time)
{
	u8 i;
	u8 j;
	u8 t;
	u8 n;
	u8 m;
	u8 RGB_A[25][3]={0};						//用于保存Array_A原始亮灯规则
	u8 RGB_A_n[25][3]={0};						//用于保存Array_A亮度递减规则
	u8 RGB_B[25][3]={0};						//用于保存Array_B原始亮灯规则
	u8 RGB_B_n[25][3]={0};						//用于保存Array_B亮度递减规则
	
	for(i=0;i<25;i++)							//Array_A/Array_B处理					
	{
		for(j=0;j<3;j++)
		{
			RGB_A[i][j]=*(Array_A+3*i+j);		//保存原始亮灯规则
			RGB_B[i][j]=*(Array_B+3*i+j);		//保存原始亮灯规则
			n=(*(Array_A+3*i+j))/Num+1;			//当前色每次需递减的亮度（考虑余数过大和为0的情况，n在原基础上+11）
			m=(*(Array_B+3*i+j))/Num+1;			//当前色每次需递减的亮度（考虑余数过大和为0的情况，m在原基础上+1）
			RGB_A_n[i][j]=n;					//保存亮度递减规则
			RGB_B_n[i][j]=m;					//保存亮度递减规则			
		}
	}
	
	t=time/(Num+1);								//每次亮灯时间	
	
	for(i=0;i<Num;i++)							//分Num层渐弱，如3时为亮-中等-灭	
	{
		reduct(&RGB_A[0][0],&RGB_A_n[0][0],25);	//将&RGB_A[0][0]所指的前25行元素减去对应的RGB_A_n，相当于前25个LED亮度减少RGB_A_n
		reduct(&RGB_B[0][0],&RGB_B_n[0][0],25);	//将&RGB_B[0][0]所指的前25行元素减去对应的RGB_B_n，相当于前25个LED亮度减少RGB_B_n
		Light_LED(LED0,&RGB_A[0][0],25);		//以&RGB_A[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB_B[0][0],25);		//以&RGB_B[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN		
		if(state!=ZT) break;	
#endif		
	}
}

/*******************************************************************************
名称：void reduct(u8 * Array,u8 * Array_n,u8 len)	
功能： 将前len个LED亮度减少n。本质是将数组的前len行元素减去n
入参：* Array指向亮灯规则；* Array_n指向亮度递减规则；len为所操作的LED个数
出参：
返回：
*******************************************************************************/	
void reduct(u8 * Array,u8 * Array_n,u8 len)	
{
	u8 i;
	u8 *p;
	u8 *n;
	len=3*len;									//需要操作3*len个色彩值
	for(i=0;i<len;i++)
	{
		p=Array+i;
		n=Array_n+i;
		if((*p)>=(*n))
		{			
			*p=(*p)-(*n);						//每个数组元素(Array+i)都减去对应的亮度修正值(Array_n+i)
		}
		else *p=0;
	}
}

/*******************************************************************************
名称：void Huxi(u8 * Array,u8 Num,u16 time)
功能： 以Array为规则，控制LED0和LED1在time时间内按Num层亮度渐弱
入参：Num为渐弱层数；time为渐弱时长（毫秒）；* Array指向亮灯规则
出参：
返回：
*******************************************************************************/		
void Huxi(u8 * Array,u8 Num,u16 time)
{
	u8 i;
	u8 j;
	u8 t;
	u8 n;
	u8 RGB[32][3]={0};							//用于保存原始亮灯规则
	u8 RGB_n[32][3]={0};						//用于保存亮度递减规则
	u8 RGB_none[32][3]={0};						//
	u8 RGB_0[32][3]={0};						//用于标记初始亮度为0的色彩位置
	
	for(i=0;i<32;i++)							
	{
		for(j=0;j<3;j++)
		{
			RGB[i][j]=*(Array+3*i+j);			//保存原始亮灯规则
			n=(*(Array+3*i+j))/Num;				//当前色每次需递减的亮度（为避免余数过大的情况，n在原基础上+1）
			if(n)								//非0
			{
				RGB_n[i][j]=n+1;				//保存亮度递减/增规则
			}
			else
			{
				RGB_n[i][j]=1;					//亮度不足以支持Num层递减，则每次递减1（层数将不到Num）
				RGB_0[i][j]=1;					//标记初始亮度为0的色彩位置
			}
		}
	}
	
	t=time/(Num+1);								//每次亮灯时间	
	
	for(i=0;i<Num;i++)							//分Num层渐亮，如3时为灭-中等-亮	
	{
		increase(&RGB_none[0][0],&RGB_n[0][0],32,&RGB_0[0][0]);		//将&RGB_none[0][0]所指的前25行元素增加对应的RGB_n，相当于前25个LED亮度增加RGB_n
		Light_LED(LED0,&RGB_none[0][0],32);		//以&RGB_none[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB_none[0][0],32);		//以&RGB_none[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
//		Res_WS2812();							//LED复位（其实只要前面延时大于50us就已经复位）
	}
	for(i=0;i<Num;i++)							//分Num层渐弱，如3时为亮-中等-灭	
	{
		reduct(&RGB[0][0],&RGB_n[0][0],32);		//将&RGB[0][0]所指的前25行元素减去对应的RGB_n，相当于前25个LED亮度减少RGB_n
		Light_LED(LED0,&RGB[0][0],32);			//以&RGB[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB[0][0],32);			//以&RGB[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
//		Res_WS2812();							//LED复位（其实只要前面延时大于50us就已经复位）
	}
}

/*******************************************************************************
名称：void Huxi2(u8 * Array_A,u8 * Array_B,u8 Num,u16 time)
功能： 以Array为规则，控制LED0和LED1在time时间内按Num层亮度渐弱
入参：Num为渐弱层数；time为渐弱时长（毫秒）；* Array指向亮灯规则
出参：
返回：
*******************************************************************************/		
void Huxi2(u8 * Array_A,u8 * Array_B,u8 Num,u16 time)
{
	u8 i;
	u8 j;
	u8 t;
	u8 n;
	u8 m;
	u8 RGB_A[25][3]={0};						//用于保存原始亮灯规则
	u8 RGB_A_n[25][3]={0};						//用于保存亮度递减规则
	u8 RGB_A_none[25][3]={0};					//
	u8 RGB_A_0[25][3]={0};						//用于标记初始亮度为0的色彩位置
	u8 RGB_B[25][3]={0};						//用于保存原始亮灯规则
	u8 RGB_B_n[25][3]={0};						//用于保存亮度递减规则
	u8 RGB_B_none[25][3]={0};					//
	u8 RGB_B_0[25][3]={0};						//用于标记初始亮度为0的色彩位置	
	
	for(i=0;i<25;i++)							
	{
		for(j=0;j<3;j++)
		{
			RGB_A[i][j]=*(Array_A+3*i+j);		//保存原始亮灯规则
			RGB_B[i][j]=*(Array_B+3*i+j);		//保存原始亮灯规则
			n=(*(Array_A+3*i+j))/Num;			//当前色每次需递减的亮度
			m=(*(Array_B+3*i+j))/Num;			//当前色每次需递减的亮度
			if(n)								//非0
			{
				RGB_A_n[i][j]=n+1;				//保存亮度递减/增规则（为避免余数过大的情况，n在原基础上+1）
			}
			else
			{
				RGB_A_n[i][j]=1;				//亮度不足以支持Num层递减，则每次递减1（层数将不到Num）
				RGB_A_0[i][j]=1;				//标记初始亮度为0的色彩位置
			}
			if(m)								//非0
			{
				RGB_B_n[i][j]=m+1;				//保存亮度递减/增规则（为避免余数过大的情况，m在原基础上+1）
			}
			else
			{
				RGB_B_n[i][j]=1;				//亮度不足以支持Num层递减，则每次递减1（层数将不到Num）
				RGB_B_0[i][j]=1;				//标记初始亮度为0的色彩位置
			}
		}
	}
	
	t=time/(Num+1);								//每次亮灯时间	
	
	for(i=0;i<Num;i++)							//分Num层渐亮，如3时为灭-中等-亮	
	{
		increase(&RGB_A_none[0][0],&RGB_A_n[0][0],25,&RGB_A_0[0][0]);		//将&RGB_A_none[0][0]所指的前25行元素增加对应的RGB_A_n，相当于前25个LED亮度增加RGB_A_n
		increase(&RGB_B_none[0][0],&RGB_B_n[0][0],25,&RGB_B_0[0][0]);		//将&RGB_B_none[0][0]所指的前25行元素增加对应的RGB_B_n，相当于前25个LED亮度增加RGB_B_n
		Light_LED(LED0,&RGB_A_none[0][0],25);	//以&RGB_A_none[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB_B_none[0][0],25);	//以&RGB_B_none[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN		
		if(state!=DJ) break;
#endif		
	}
	for(i=0;i<Num;i++)							//分Num层渐弱，如3时为亮-中等-灭	
	{
		reduct(&RGB_A[0][0],&RGB_A_n[0][0],25);	//将&RGB_A[0][0]所指的前25行元素减去对应的RGB_A_n，相当于前25个LED亮度减少RGB_A_n
		reduct(&RGB_B[0][0],&RGB_B_n[0][0],25);	//将&RGB_B[0][0]所指的前25行元素减去对应的RGB_B_n，相当于前25个LED亮度减少RGB_B_n
		Light_LED(LED0,&RGB_A[0][0],25);		//以&RGB_A[0][0]为规则，将LED0点亮25个
		Light_LED(LED1,&RGB_B[0][0],25);		//以&RGB_B[0][0]为规则，将LED1点亮25个
		delay_ms(t);							//亮t(ms)
		IWDG_Feed();							//喂狗
#if ZHONGXIN		
		if(state!=DJ) break;
#endif		
	}
}

/*******************************************************************************
名称：void increase(u8 * Array,u8 * Array_n,u16 len,u8 * Array_0)	
功能： 将前len个LED亮度增加n。本质是将数组的前len行元素加上n
入参：* Array指向亮灯规则；* Array_n指向亮度递增规则；len为所操作的LED个数；* Array_0指向0色值标记数组
出参：
返回：
*******************************************************************************/	
void increase(u8 * Array,u8 * Array_n,u16 len,u8 * Array_0)	
{
	u8 i;
	u8 *p;
	u8 *n;
	u8 *p_0;
	len=3*len;									//需要操作3*len个色彩值
	for(i=0;i<len;i++)
	{
		p=Array+i;
		n=Array_n+i;
		p_0=Array_0+i;
		if((*p_0)==1) continue;					//初始色值为黑处跳过，防止0色彩每次+1
		if((*p)<=255-(*n))
		{			
			*p=(*p)+(*n);						//每个数组元素(Array+i)都减去对应的亮度修正值(Array_n+i)
		}
		else *p=255;
	}
}

/*******************************************************************************
名称：void LED1_Send_8bits(u8 date)
功能： 向数据线输出8字节
入参：u8 ID为LED串编号；u8 date 8位数据
出参：
返回：
*******************************************************************************/
void LED1_Send_8bits(u8 date)
{
	u8 i;
	for(i=0;i<8;i++)
	{
		if(date&0x80) {LED1_CODE1}				//若最高位为1，输出1时序
		else {LED1_CODE0}						//输出0时序
	}	
}

/*******************************************************************************
名称：void LED0_Send_8bits(u8 date)
功能： 向数据线输出8字节
入参：u8 ID为LED串编号；u8 date 8位数据
出参：
返回：
*******************************************************************************/
void LED0_Send_8bits(u8 date)
{
	u8 i;
	for(i=0;i<8;i++)
	{
		if(date&0x80) {LED0_CODE1}				//若最高位为1，输出1时序
		else {LED0_CODE0}						//输出0时序
	}
}

/*******************************************************************************
名称：void LED0_Send_pixel(u8 * Array)
功能： 向数据线输出24位RGB数据（一个像素）	注意顺序为GRB
入参：u8 ID为LED串编号；u8 * Array  指向要显示的24位RGB数据地址
出参：
返回：
*******************************************************************************/
void LED0_Send_pixel(u8 * Array)
{//Note: Follow the order of GRB to sent data and the high bit sent at first.	
	LED0_Send_8bits(*(Array+1));		//发送G
	LED0_Send_8bits(*Array);			//发送R
	LED0_Send_8bits(*(Array+2));		//发送B
}

/*******************************************************************************
名称：void LED1_Send_pixel(u8 * Array)
功能： 向数据线输出24位RGB数据（一个像素）	注意顺序为GRB
入参：u8 ID为LED串编号；u8 * Array  指向要显示的24位RGB数据地址
出参：
返回：
*******************************************************************************/
void LED1_Send_pixel(u8 * Array)
{//Note: Follow the order of GRB to sent data and the high bit sent at first.	
	LED1_Send_8bits(*(Array+1));		//发送G
	LED1_Send_8bits(*Array);			//发送R
	LED1_Send_8bits(*(Array+2));		//发送B
}

/*******************************************************************************
名称：void Light_LED(u8 ID,u8 * Array,u8 Num)
功能： 以* Array数组为规则（定义了每个LED色彩），点亮Num个将对应ID串的LED
入参：u8 ID为LED串编号；u32 * Array 指向数组的指针；u8 Num，LED个数
出参：
返回：
*******************************************************************************/
void Light_LED(u8 ID,u8 * Array,u8 Num)
{
	u8 i;
	if(ID==LED0)
	{
		for(i=0;i<Num;i++)						//共点亮Num个LED
		{
			LED0_Send_pixel(Array+3*i);			//发送一个像素数据（点亮一个LED）
		}			
	}
	else
	{
		for(i=0;i<Num;i++)						//共点亮Num个LED
		{
			LED1_Send_pixel(Array+3*i);			//发送一个像素数据（点亮一个LED）
		}	
	}
			
}

/*******************************************************************************
名称：void Res_WS2812(void)
功能： LED接收到两次发光命令之间必须的复位时序，否则会向后传递
入参：
出参：
返回：
*******************************************************************************/
void Res_WS2812(void)
{
	delay_us(55);								//需>50us
}
